# Интенсив по мобильной разработке от Яндекс в университете Сириус
Интенсив проходил в течение двух недель, по результатам работы мной был получен сертификат об успешном освоении программы в 88 академических часов. 

Я вёл проектную работу по разработке мобильного приложения на _Flutter_
(**_Flutter_** – **кроссплатформенный фреймворк** для создания **нативных** мобильных, веб- и десктопных приложений из **единой кодовой базы** на языке **_Dart_**)  

Нашим ментором из команды _ЯндексПро_ было предложено абстрактное видение задачи. Мы, доработав её до полноценного ТЗ, приступили к реализации superapp **"GymBro"** 

## GymBro superapp
Подробнее: https://github.com/PervuhinRoman/GymBroForPress

**GymBro** – приложение для всех, кто занимается спортом, сочатющее в себе:
1. **AI-ассистента** для составления расписания и наполнения тренировок
2. **Карту** залов с возможностью оценки их загруженности
3. Поиск твоего _Gym-Bro_ для совместных тренировок в _**"Tinder like"**_ стиле
4. **Календарь** тренировок для контроля режима занятий спортом

## Приобритённые знания
## Dart
В ходе обучения мы ознакомились со всеми концепциями языка Dart. Некоторые из них подавались сжато в целях экономии времени. Тем не менее были полностью разъесняны следующие темы:
+ Базовый синтаксис
+ Типы данных
+ Null-safety
+ Управляющие операторы
+ "Синтаксический сахар" языка
+ Реализация ООП в Dart

Подробного описания заслуживают:
### Null-Safety
> The Dart language enforces sound null safety.
> Null safety prevents errors that result from unintentional access of variables set to null.
> – [Официальная документация Dart](https://dart.dev/null-safety)

Null-safety в Dart — это механизм, который помогает избежать ошибок, связанных с обращением к null (нулевым ссылкам). Он делает типы данных по умолчанию не nullable (не могут быть null), если явно не указано обратное.

Познакомились с механизмами работы операторов:
1. `!` ("bang"-оператор) – утверждение, что значение не null (опасно, если ошибочно)
2. `?.` (conditional access) — безопасный доступ
3. `??` (null-coalescing) — значение по умолчанию

Null-Safety стала важным нововведением в Dart, т.к. теперь все сущности, плагины, пакеты должны следовать этой парадигмы, а все предыдущии версии без null-safety не обратносовместимы.

### ООП
Язык Dart реализует классическую схему ООП, но имеет обширный ряд особенностей и полезных фич, с которым мы познакомились:

1. Инкапсуляция
Доступ к членам класса регулируется только двумя модификаторами:
    + public (по умолчанию) — доступ отовсюду внутри библиотеки.
    + private (с подчеркиванием `_`) — только внутри файла.

2. Наследование
Dart поддерживает одиночное наследование (один родительский класс) через ключевое слово extends. Для переопределения методов используется @override. Миксины (mixin, with) позволяют добавлять функциональность без множественного наследования.

4. Миксины (Mixins)
Уникальная черта Dart — миксины, которые позволяют подмешивать функциональность в классы без наследования. Определяются через mixin и подключаются к классу через with. Отличаются от интерфейсов тем, что могут содержать реализацию методов.

5. Полиморфизм
Переопределение методов (override) — дочерние классы могут менять поведение родительских методов.
**Интерфейсы — все классы неявно определяют интерфейс, который можно реализовать через implements.**
Абстрактные классы (abstract) — могут содержать абстрактные методы (без реализации), требующие переопределения в дочерних классах.

6. Интерфейсы
В Dart нет отдельного ключевого слова для интерфейсов — любой класс может быть интерфейсом. Класс может реализовывать (implements) несколько интерфейсов, но наследовать (extends) — только один.

7. Фабричные конструкторы
Dart позволяет создавать объекты через фабричные конструкторы (factory), которые могут возвращать экземпляры из кэша или подклассов, нарушая стандартное правило о возврате нового объекта.

8. Каскадная нотация (Cascade)
Синтаксис .. (двойная точка) позволяет выполнять несколько операций над одним объектом без повторного обращения к нему. Это особенно полезно для цепочек вызовов методов.

11. Null-safety и ООП
С включенной null-безопасностью все типы по умолчанию non-nullable. Это влияет на поля классов, методы и наследование, требуя явного указания ? для nullable-типов.

12. Расширения (Extension Methods)
Позволяют добавлять методы к существующим классам без их модификации, даже к стандартным типам (String, int).

13. Иммутабельность и const-конструкторы
Dart поощряет иммутабельность: классы могут иметь const-конструкторы для создания неизменяемых объектов, которые кэшируются на этапе компиляции.

## Асинхронность
Является важной состовляющей любого языка прогшраммирования.
Тема асинхронности рассматривалась сразу в парадигме Fluttter.
Так, асинхронность в Flutter имеет ряд особенностей:
+ В данных технологиях есть чёткое разгарничение понятий: синхронный код, асинхронный код и параллелизм
+ "Асинхронность" осуществляется на уровне виртуальной машины Dart
+ "Параллелизм" осущетсвляется на нативном уровне системы (использование "изолятов")

### Асинхронность
"Весь код в Dart и Flutter синхронный". 
Dart VM использует однопоточную модель. Это значит, что весь код выполянется внутри одного потока (изолята) системы. Когда мы реализуем "асинхронную" реализацию, на самом деле мы запускаем процесс синхронного переключения между процессами, в итоге достигается эффект асинхронного выполнения. Данный процесс контролирует Event Loop

- [ ] Изображение

### Параллелизм
Достичь дейтсвительно параллельного выполенняи кода для по-настоящему тяжеловесных операций можно с помощью механизма изолятов.
На практике нам не пришлось обращаться к нему, но основыне методы работы были рассмотренны.

- [ ] Изображение
  
## Flutter
Разумеется были рассмотренны основы программирования на самом Flutter. Перечень тем, которые были изучены с наставниками и самостоятельно:
1. Понятие Widget, виды виджетов
2. Понятие состояния
3. WidgetTree
4. Понятие Element
5. ElementTree
6. Ключи
7. InheretedWidget
8. Анимации
9. Навигация
10. Хранение данных

## State Managment
**State Managemen**t (управление состоянием) — это подход к организации данных, которые изменяются во время работы приложения, и их синхронизации между различными частями программы. В любом приложении есть состояние (например, данные пользователя, настройки, UI-состояния), и важно управлять им эффективно.

Основные принципы:
+ Единый источник истины (Single Source of Truth) — состояние хранится в одном месте.
+ Реактивность — автоматическое обновление зависимых частей при изменении состояния.
+ Инкапсуляция логики — отделение бизнес-логики от UI.

Мы выделили и изучили 3 вида StateManagment в Flutter:
1. Встроенный
2. Рекомендуемый Flutter Team
3. Сторонний

Поддерживать выполнение основных принципов можно с помощью стандартных инстурментов фреймворка: `setState()`, `inheretdWidget` и т.д., но этот путь громоздкий и плохо масштабируемый в рамках больших проектов.

Тогда можно использовать более продивнутый способ – [Provider](https://pub.dev/packages/provider). По сути это удобная обёртка над вышеописанным не всегда удобным способом.

И тем не менее сущетсвуют множество других подходов и путей для организации StateManagment в Flutter. Для нашего проекта был применён [Riverpod](https://riverpod.dev/). Ещё более глубокая модернизация Provider. 
Данный фреймворк был выбран также потому что реализует механизмы DI (Dependency Injection (DI) — механизм, который автоматически предоставляет зависимости (например, сервисы, репозитории, конфиги) там, где они нужны, без ручного создания экземпляров), который стал необходим в нашем superapp.

## Архитектруа
Нами была изучена архитектура мобильных приложений.
Мы выделили несколько уровней архитектуры:

1. Уровень кода (code style, effective dart, linter, чистый код)
2. Уровень классов (принципы SOLID, DRY, KISS, YAGNI)
3. Организация компонентов (rep, ccp, crp, adp, sdp, sap; паттерны проектирования)
4. Уровень приложения (арх.шаблоны, dependencies & state management)

В общих чертах были рассмотрены все уровни. Особое внимание мы уделили уровню классов (за соблюдением принципов следил наш ментор в качестве ревьюира кода в github) и уровню приложения. 

(так или инчае при разработке задеваются все уровни, разница лишь в том, насколько много осознаного внимания уделяется каждому из них)

В итоге наше приложение реализует:
> MVVM, Riverpod specific архитектуру с разделением на слои упрощённого clean-а и Feature-fisrt подходом.
   
## Устройство нативных частей iOS и Android
Сложной, но необходимой темой является изучение нативных особенностей платформ, на которые будет осуществляться деплой продукта.

Главная особенность и отличие Flutter от других кросс-платформенных фреймворков в том, что Flutter самрисует каждый пиксель на экране, в архитектуре нет "моста" между Flutter и нативом, Flutter не просит платформу отобразить кнопку, а сам рисует её. Наиболее точно это можно сравнить с игровым движком (игры выглядят одинаково на разных плафтормах). В большинстве задач нам не приходится обращаться к нативной части, но бывают и исключения, когда одни и те же механизмы (напрмер взаимодействие с геоданными, как будет показано дальше) имеют разную нативную реализаию и не поддаются централизованному замещению движком Dart.

В GymBro я также отвечал за интеграцию карты от Яндекс для реализации функционала выбора наименее загруженного зала, для этого было необходимо:
1. Написать некоторый объём кода на нативных языках для платформ Android и iOS (Kotlin и Swift соответсвенно)
2. В настройках нативных частей проекта предоставить соответвующие разрешения приложения для доступа к геоданным
3. В системах сборки каждой платформы выполнить подключение SDK карт Яндекс
4. Решить сопутствующие проблемы

Пункт 4 почётно находится в этом списке, потому что он один занимает уверенные 75% от всего объёма заадче по интеграции карт.

Для решения этой задачи пригодились следующие изученные темы:
+ Работа Gradle (в т.ч. Gradle.kts) для Android
+ Работа Cocoapods для iOS
+ Понимание Manifest для Android
+ Понимание info.plist для iOS
+ Принципы работы Dart VM

Как видим совсем чуть-чуть (нет)

## Тестирование и Deploy
### Тестирование
Ни один настоящий проект не может обойтись без тестирования. Методы контроля качества продукта, которые мы применяли в проекте:
1. Ревью кода опытным ментором
2. Использование linter-а
3. Осуществление CI/CD тестов в GitHub
4. Созадние Unit-тестов

Изучили, но на практике не применили:
1. Созадние Widget/Golden-тестов
2. Создание E2E-тестов

### Deploy
Нами были изучены процессы получения артифакта приложения для двух платформ: Android и iOS. На практике удалось создать только артифакт Android. Это связано с тем, что лицензия Apple для публикации приложения намного более труднодоступна в силу в том числе политических факторов.

Для деплоя вновь стало необходимым углубиться в особенности работы Dart VM и некотрых других нативных процессов в Flutter фреймворке.

### Не mobile development
Т.к. в рамках проектной работы на интенсиве нам было необходимо осуществить полный цикл разработки приложения, были затронуты темы, которые на прямую не связаны с преподаваемым матреиалом.

Так, я познакомился с технологией быстрой разработки backend-части (в т.ч. хранилища данных) средствами Firestore. 

В проекте также применялась технология Firebase и сервер на GoLang.

## Итоги
Итогом работы стала бета-версия приложения GymBro – superapp-сервиса для совметсных тренировок. Проект был представлен на общей сессии защиты проектов в финальный день интеснива, где получил положительные отзывы менторского жюри и других команд. 

В ходе разработки и обучения мы охвотили множество тем, часть из которых была описана выше. Объёма этих знаний достаточно для самостоятельной разработки мобильных кроссплатформенных приложений на технологии Flutter. Разумеется данные знания необходимо углублять и совершенствовать, и план по их развитию – ещё одна ценность, которую можно вынести с данного интенсива 
